package generated.fr.ul.miage.tdCup;
import fr.ul.miage.arbre.*;

// code java
parser code {:
    public Noeud resultat = null;
:}

terminal String IDF;
terminal SI, SINON, ECRIRE, TANTQUE, RETOUR, INT, FONCTION, LIRE;
terminal Integer NUM;
terminal ADD, SUB, MUL, DIV, PO, PF, SUP, INF, SEQ, IEQ, EQ, DIF, AO, AF, PV, VIR, AFF;
//        +   -    *    /    (   )   >    <    >=   <=   ==  !=   {   }   ;   ,    =

non terminal Noeud expression, facteur, atome,
expressionBooleene,
blocInstruction, blocDeclaration,
conditionnelle,
affectation,
ecrire,
tantque,
retour,
appel,
parametre, parametre2,
instruction,
fonction,
lire,
programme, programme2,
defParam, defParam2, defIdf, declaration;
start with programme;

expression ::= expression:e ADD facteur:f {:
        RESULT = new Plus();
        ((Plus)RESULT).setFilsGauche(e);
        ((Plus)RESULT).setFilsDroit(f);
    :}
    | expression:e SUB facteur:f {:
        RESULT = new Moins();
        ((Moins)RESULT).setFilsGauche(eg);
        ((Moins)RESULT).setFilsDroit(ed);
    :}
    | facteur:f {:

    :}
    ;
facteur ::= facteur:f MUL atome:a
    | facteur:f DIV atome:a
    | atome:a
    ;
atome ::= NUM
    | PO expression:e PF
    | IDF:i
    | lire:l
    | appel:a
    ;

expressionBooleene ::= expression:eg SUP expression:ed {:
        RESULT = new Superieur();
        ((Superieur)RESULT).setFilsGauche(eg);
        ((Superieur)RESULT).setFilsDroit(ed);
    :}
    | expression:eg INF expression:ed {:
        RESULT = new Inferieur();
        ((Inferieur)RESULT).setFilsGauche(eg);
        ((Inferieur)RESULT).setFilsDroit(ed);
    :}
    | expression:eg SEQ expression:ed {:
        RESULT = new SuperieurEgal();
        ((SuperieurEgal)RESULT).setFilsGauche(eg);
        ((SuperieurEgal)RESULT).setFilsDroit(ed);
    :}
    | expression:eg IEQ expression:ed {:
        RESULT = new InferieurEgal();
        ((InferieurEgal)RESULT).setFilsGauche(eg);
        ((InferieurEgal)RESULT).setFilsDroit(ed);
    :}
    | expression:eg EQ expression:ed {:
        RESULT = new Egal();
        ((Egal)RESULT).setFilsGauche(eg);
        ((Egal)RESULT).setFilsDroit(ed);
    :}
    | expression:eg DIF expression:ed {:
        RESULT = new Different();
        ((Different)RESULT).setFilsGauche(eg);
        ((Different)RESULT).setFilsDroit(ed);
    :}
    ;

blocInstruction ::= instruction:i blocInstruction:bi
    | //vide
    ;

blocDeclaration ::= declaration:d blocDeclaration:bd
    | //vide
    ;

conditionnelle ::= SI PO expressionBooleene:eb PF AO blocInstruction:bsi AF
                    SINON AO blocInstruction:bsinon AF
    ;

affectation ::= IDF AFF expression:e PV
    ;

ecrire ::= ECRIRE PO expression:e PF PV {:
        RESULT = new Ecrire();
        ((Ecrire)RESULT).setLeFils(e);
    :}
    ;

tantque ::= TANTQUE PO expressionBooleene:eb PF AO blocInstruction:b AF {:
        RESULT = new TantQue();
        ((TantQue)RESULT).setCondition(eb);
        ((TantQue)RESULT).setBloc(b);
    :}
    ;

retour ::= RETOUR expression:e PV {:
        RESULT = new Retour();
        ((Retour)RESULT).setLeFils(e);
    :}
    | RETOUR PV
    ;

appel ::= IDF PO parametre:p PF PV {:
        RESULT = new Appel();
    :}
    ;

parametre ::= parametre2:p
    | //vide
    ;
parametre2 ::= expression:e
    | expression:e VIR parametre2:p
    ;

instruction ::= affectation:a
    | appel:a
    | ecrire:e
    | si:s
    | tantque:t
    | retour:r
    ;

fonction ::= FONCTION IDF PO defParam:d PF AO blocDeclaration:bd blocInstruction:bi AF
    ;

lire ::= LIRE {:
        RESULT = new Lire();
    :}
    ;

programme ::= blocDeclaration:bd programme2:p
    ;
programme2 ::= fonction:f programme2:p
    | fonction:f
    ;

defParam ::= defParam2:p
    | //vide
    ;
defParam2 ::= defIdf:i VIR defParam2:p
    | defIdf:i
    ;
defIdf ::= INT IDF
    ;
declaration ::= defIdf:i PV
    | defIdf:i AFF NUM PV
    ;